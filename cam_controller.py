# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'GPS_Logging_GUI.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import sys
from datetime import datetime as dt
from threading import Thread
import passive_cam
import active_cam
import pigpio
import BQ27441_source       #detect when battery soc is low. and GPOUT pin is triggered
import os                   #used to shutdown raspberry pi through python
import time


class SubWindow(QtWidgets.QWidget):
    """SubWindow creates an GUI with a button to exit out of passive cam main loop."""
    
    def __init__(self, parent = None):
        super(SubWindow, self).__init__(parent)
        
        vbox = QtWidgets.QVBoxLayout()
        
        #create pushbutton
        self.passive_cam_stop_button = QtWidgets.QPushButton("Stop Passive Cam")
        
        #click push button
        self.passive_cam_stop_button.clicked.connect(self.on_stop_passive_cam_button_clicked)
        
        font = QtGui.QFont()
        font.setPointSize(16)
        self.passive_cam_stop_button.setFont(font) 
        self.passive_cam_stop_button.setObjectName("stop_passive_cam_button")
        
        self.label = QtWidgets.QLabel("Before")
        
        
        vbox.addWidget(self.passive_cam_stop_button)
        vbox.addWidget(self.label)
        
        self.setLayout(vbox)
        
        #at position(150,150) create a 100x100 box
        self.setGeometry(150,150,100,100)
        self.setWindowTitle('Passive Cam Release')
        
        self.button_clicked = 0
        
    @QtCore.pyqtSlot()
    def on_stop_passive_cam_button_clicked(self):
        print("Stop")
        self.label.setText("After")
        
        #flag used to exit out of passive_cam loop
        self.button_clicked =1

    def closeEvent(self, event):
                close = QtWidgets.QMessageBox.question(self,
                                             "QUIT",
                                             "Are you sure want to stop process?",
                                             QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
                
                #SubWindow Base class event: X button
                #
                #
                #If X button is pressed a text box pops up.
                #if user selects Yes, we accept clicking the X button. (SubWindow base class exits)
                #If user selects No, we ignore the X button click of the base class SubWindow base class.
                #
                #
                if close == QtWidgets.QMessageBox.Yes:
                    #calls an exit function for the window
                    event.accept()
                else:
                    #ignores the exit function for the window and goes back to SubWindow
                    event.ignore()
                    
                    
#subclass of mainwindow to customize application main window
class UI_MainWindow(QtWidgets.QMainWindow):

    def __init__(self,PI_GPIO,*args,**kwargs):
        
        #inherit all attributes from QMainWindow parent
        super(UI_MainWindow,self).__init__(*args,**kwargs)
        
        self.pi = PI_GPIO
        
        self.resize(370, 262)
        self.setWindowTitle("MainWindow")
        
        self.centralwidget = QtWidgets.QWidget(self)
        self.centralwidget.setObjectName("centralwidget")
        
        
        self.passive_cam = QtWidgets.QPushButton(self.centralwidget)
        self.passive_cam.setGeometry(QtCore.QRect(73, 52, 80, 73))
        font = QtGui.QFont()
        font.setPointSize(6)
        self.passive_cam.setFont(font)
        self.passive_cam.setObjectName("passive_cam")
        self.passive_cam.setStyleSheet("background-color : yellow")
        self.passive_cam.clicked.connect(self.on_passive_cam_clicked)
        
        
        self.active_cam = QtWidgets.QPushButton(self.centralwidget)
        self.active_cam.setGeometry(QtCore.QRect(189, 52, 80, 73))
        font = QtGui.QFont()
        font.setPointSize(6)
        self.active_cam.setFont(font)
        self.active_cam.setObjectName("active_cam")
        self.active_cam.setStyleSheet("background-color : yellow")
        self.active_cam.clicked.connect(self.on_active_cam_clicked)
        
        
        self.current_mode_label = QtWidgets.QLabel(self.centralwidget)
        self.current_mode_label.setGeometry(QtCore.QRect(280, 3, 87, 14))
        font = QtGui.QFont()
        font.setPointSize(6)
        self.current_mode_label.setFont(font)
        self.current_mode_label.setObjectName("current_mode_label")
        self.current_mode_label.setStyleSheet("background-color : yellow")

        self.TimeStamp_label = QtWidgets.QLabel(self.centralwidget)
        self.TimeStamp_label.setGeometry(QtCore.QRect(280, 175, 87, 14))
        font = QtGui.QFont()
        font.setPointSize(6)
        self.TimeStamp_label.setFont(font)
        self.TimeStamp_label.setObjectName("TimeStamp_label")
        
        self.ellapsed_time_label = QtWidgets.QLabel(self.centralwidget)
        self.ellapsed_time_label.setGeometry(QtCore.QRect(280, 210, 87, 14))
        font = QtGui.QFont()
        font.setPointSize(6)
        self.ellapsed_time_label.setFont(font)
        self.ellapsed_time_label.setObjectName("Ellapsed_Time_label")
        
        self.status_indicator = QtWidgets.QLabel(self.centralwidget)
        self.status_indicator.setGeometry(QtCore.QRect(101, 182, 126, 31))
        font = QtGui.QFont()
        font.setPointSize(6)
        self.status_indicator.setFont(font)
        self.status_indicator.setObjectName("status_indicator")
        
        #enable widgets in the main window
        self.setCentralWidget(self.centralwidget)
        
        self.passive_clicked = 0
        self.active_clicked = 0
        
        self.retranslateUi()

        #matches action signals like button clicks to Widget objects
        QtCore.QMetaObject.connectSlotsByName(self)
        
        self._generator = None
        self._timerId = None
        
        #implement passive cam clicked function at start.
        self.on_passive_cam_clicked()

    def retranslateUi(self):
        _translate = QtCore.QCoreApplication.translate
        self.setWindowTitle(_translate("MainWindow", "Camera App"))
        self.passive_cam.setText(_translate("MainWindow", "Camera Passive"))
        self.active_cam.setText(_translate("MainWindow", "Camera Active"))
        self.current_mode_label.setText(_translate("MainWindow", "Current Mode"))
        self.status_indicator.setText(_translate("MainWindow", "Connecting..."))

    @QtCore.pyqtSlot()
    def on_passive_cam_clicked(self):
        print("Start")
        self.status_indicator.setText("Passive Camera On")
        self.status_indicator.adjustSize()
        
        self.current_mode_label.setText("Passive Camera On")
        self.current_mode_label.adjustSize()

        self.active_cam.setStyleSheet("background-color : yellow")
        self.passive_cam.setStyleSheet("background-color : green")

        self.current_mode_label.setStyleSheet("background-color : green")
        
        #cannot click on passive cam anymore
        self.passive_cam.setEnabled(False)
        self.active_cam.setEnabled(False)
        
        #open subwindow
        self.sub = SubWindow()
        self.sub.show()
        
        #kill previous timer and reset timer details before starting the loop
        self.stop_timer()
        
        self._generator = self.loopGenerator(self.sub)  # Start the loop
        
        #timer occurs every time once there are no more window events to process (ex. passive_cam out end of loop)
        self._timerId = self.startTimer(0)   # This is the idle timer
        
        self.passive_cam.setEnabled(True)
        self.active_cam.setEnabled(True)
        
    
    def stop_timer(self):
        """Reset the timer."""
        if self._timerId is not None:
            self.killTimer(self._timerId)
        self._generator = None
        self._timerId = None
        
        
    def loopGenerator(self,sub_window):
        """ runs the passive cam script, uses generator "yield" to control loop iteration."""
        
        #Enable Voltage sensing reference signal
        VS = 24
        self.pi.set_mode(VS, pigpio.INPUT)
        
        #setup passive cam
        self.passive_cam_obj = passive_cam.Passive_Cam(self.pi, passive_cam.PIR, passive_cam.temp_sensor, passive_cam.PB, passive_cam.FAN_SWITCH)
        
        #setup battery baby sitter
        BQ = BQ27441_source.BQ27441(self.pi, BQ27441_source.GPOUT_PIN)
        
        #set capacity for battery baby sitter
        BQ.set_capacity(BQ27441_source.SET_CAPACITY)
        time.sleep(5)
        
        #set interrupt function for low battery 
        BQ.set_GPOUT( BQ27441_source.SOCI_SET, BQ27441_source.SOCI_CLR, BQ27441_source.SOCF_SET, BQ27441_source.SOCF_CLR, BQ27441_source.BAT_LOW, 0)
        time.sleep(5)
        
        BQ.test_read()
        
        while True:
        
            pin_4_read = self.pi.read( BQ27441_source.GPOUT_PIN )

            #If the GPOUT interrupt is active (low)
            if ( pin_4_read == 0 ):
            
                flagState = BQ.read_flags() 
                SOC1 = (flagState & 0x04) & ( 1 << 2)         #BQ27441_FLAG_SOC1 (1<<2)
                SOCF = (flagState & 0x02) & ( 1 << 1)         #BQ27441_FLAG_SOCF (1<<1)
                
                #print( "GPOUT PIN -  ", "SOC1: ", SOC1, " ", "SOCF: ", SOCF )
            
                if ( SOCF ):
                    print( "<!-- WARNING: Battery Dangerously low -->" )
                elif( SOC1 ):
                    print( "<!-- WARNING: Battery Low -->")
                
                #if mains power is disconnected shut off pi
                if (self.pi.read(VS) == 0):
                    print("Shutting Down...")
                    print("POWER IS LOW, System is shutting down.")
                    os.system('systemctl poweroff')
                
        
            #if PB is pressed break
            if(self.passive_cam_obj.roll() == 0):
                break
                
            #if GUI button is pressed break
            if (sub_window.button_clicked ==1):
                break
                
            # No processEvents() needed, just "pause" the loop using yield
            yield
            
            
    def timerEvent(self, event):
        """This is called every time the GUI is idle.
        Or loopGenerator reaches the yield statement
        """
        
        #if self.loopGenerator is not running return None
        if self._generator is None:
            return
        
        #try to grab next iteration, if there is an error, stop the timer.
        try:
            next(self._generator)  # Run the next iteration
        except StopIteration:
            self.stop_timer()

    @QtCore.pyqtSlot()
    def on_active_cam_clicked(self):
        print("Stop")
        self.status_indicator.setText("Active Camera On")
        self.status_indicator.adjustSize()
        
        self.current_mode_label.setText("Active Camera On")
        self.current_mode_label.adjustSize()

        self.active_cam.setStyleSheet("background-color : green")
        self.passive_cam.setStyleSheet("background-color : yellow")

        self.current_mode_label.setStyleSheet("background-color : yellow")
        
        self.active_cam.setEnabled(False)
        self.passive_cam.setEnabled(False)
        
        self.active_cam_obj = active_cam.live_stream()
        self.active_cam_obj.roll()
        
        self.active_cam.setEnabled(True)
        self.passive_cam.setEnabled(True)


    def closeEvent(self, event):
        close = QtWidgets.QMessageBox.question(self,
                                     "QUIT",
                                     "Are you sure want to stop process?",
                                     QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
        
        #SubWindow Base class event: X button
        #
        #
        #If X button is pressed a text box pops up.
        #if user selects Yes, we accept clicking the X button. (SubWindow base class exits)
        #If user selects No, we ignore the X button click of the base class SubWindow base class.
        #
        #
        if close == QtWidgets.QMessageBox.Yes:
            #calls an exit function for the window
            event.accept()
        else:
            #ignores the exit function for the window and goes back to SubWindow
            event.ignore()
            
        

if __name__ == "__main__":

    #setup DHT11 sensor
    #run pigpiod before executing rest of the script.
    try:
        os.system("sudo pigpiod")
    except:
        print("daemon already running")

    #global variable to control gpio
    pi = pigpio.pi()
    if not pi.connected:
        exit()
        
    app = QtWidgets.QApplication(sys.argv)

    ui = UI_MainWindow(pi)
    ui.show()

    sys.exit(app.exec_())
    
    